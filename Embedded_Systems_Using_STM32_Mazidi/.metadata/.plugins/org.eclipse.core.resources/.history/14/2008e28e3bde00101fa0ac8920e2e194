// ADC driver programs for various ADC modules and functionalities

// Includes
#include "adc_conversion.h"

// Function declarations
// Initialize the ADC module and keep reading values from the in-built temperature sensor, and displaying them via USART
void adc_temp_conv_init(void)
{
	// Initialize Timer 2 for ADC converion signalling
	timer2_setup_adc();

	// Enable clock access to ADC1
	RCC->APB2ENR |= ADC1_CLK_EN;

	// Set the temp sensor channel - channel 18 as the first in the sequence of ADC conversion (since we have no other conversions)
	// We write channel number - 18 to SQ1 (Sequence 1) bits of ADC1 Regular Sequence Register 3.
	ADC1->SQR1 = 18;

	// Set the resolution for the ADC1 - we set it to 12 bit resolution.
	ADC1->CR1 &= ~(1UL << 24 | 1UL << 25);

	// Set the sampling time appropriately (according to the resolution).
	// Since we choose 12 bit resolution, we set sampling clock cycles to 28 cycles, in Sample Time Register 1
	ADC1->SMPR1 |= (1UL << 25);
	ADC1->SMPR1 &= ~(1UL << 24 | 1UL << 26);

	// Turn on the on-board temperature sensor connected to channel 18, we also need to disable VBAT since it is also connected to the same channel
	// - channel 18 as the temperature sensor, and when both Temp-sensor and VBAT are enabled, only the VBAT value will be read and converted.
	// We do this by setting TSVREFE bit and clearing the VBATE (VBAT Enable) bit of Common Control Register.
	ADC->CCR |= ADC1_TEMP_EN;
	ADC->CCR &= ~ADC1_VBAT_EN;

	// Set the ADC1 conversion to occur every EXTEN rising edge. Select the EXTSEL to Timer 2 channel 2 Capture/Compare Event.
	ADC1->CR2 |= (1UL << 28);
	ADC1->CR2 &= ~(1UL << 29);
	ADC1->CR2 |= (1UL << 24 | 1UL << 25);
	ADC1->CR2 &= ~(1UL << 26 | 1UL << 27);

	// Enable the ADC1
	ADC1->CR2 |= ADC1_EN;
}

// Start ADC conversion on channel 18
void start_temp_conversion(void)
{
	// Enable continuous conversion mode
	ADC1->CR2 |= ADC1_CONT_CONV_EN;

	// Start the ADC conversion
	ADC1->CR1 |= ADC1_START_CONV;
}

// Read some data from the ADC Data register once the data has been converted
uint32_t adc_read(void)
{
	// Wait for the conversion to be completed, we do this by monitoring the End of Conversion bit EOC bit in status register
	while(!(ADC1->SR & ADC1_END_OF_CONV));

	// Read the converted value and return it
	return (ADC1->DR);
}
