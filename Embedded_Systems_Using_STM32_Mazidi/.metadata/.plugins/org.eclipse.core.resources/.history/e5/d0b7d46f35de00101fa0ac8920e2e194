// ADC driver programs for various ADC modules and functionalities

// Includes
#include "adc_conversion.h"

// Function declarations
// Initialize the ADC module and keep reading values from the in-built temperature sensor, and displaying them via USART
void adc_temp_conv_init(void)
{
	// Initialize Timer 2 for ADC converion signalling
	timer2_setup_adc();

	// Initialize USART2 module for writing the ADC converted value to USART2 TX.
	usart2_init();

	// Enable clock access to ADC1
	RCC->APB2ENR |= ADC1_CLK_EN;

	// Set the temp sensor channel - channel 18 as the first in the sequence of ADC conversion (since we have no other conversions)
	// We write channel number - 18 to SQ1 (Sequence 1) bits of ADC1 Regular Sequence Register 3.
	ADC1->SQR1 = 18;

	// Set the resolution for the ADC1 - we set it to 12 bit resolution.
	ADC1->CR1 &= ~(1UL << 24 | 1UL << 25);

	// Set the sampling time appropriately (according to the resolution).
	// Since we choose 12 bit resolution, we set sampling clock cycles to 28 cycles, in Sample Time Register 1
	ADC1->SMPR1 |= (1UL << 25);
	ADC1->SMPR1 &= ~(1UL << 24 | 1UL << 26);

	// Turn on the on-board temperature sensor connected to channel 18, we also need to disable VBAT since it is also connected to the same channel
	// - channel 18 as the temperature sensor, and when both Temp-sensor and VBAT are enabled, only the VBAT value will be read and converted.
	// We do this by setting TSVREFE bit and clearing the VBATE (VBAT Enable) bit of Common Control Register

	// Set the ADC1 conversion to occur every EXTEN rising edge. Select the EXTSEL to Timer 2 channel 2 Capture/Compare Event.

	// Enable the ADC1

}

// Start ADC conversion on channel 18
void start_temp_conversion(void)
{
	// Enable continuous conversion mode

	// Start the ADC conversion
}

// Read some data from the ADC Data register once the data has been converted
uint32_t adc_read(void)
{
	// Wait for the conversion to be completed

	// Read the converted value and return it
}
