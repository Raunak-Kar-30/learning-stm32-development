// Driver program for implementing the USART RX and TX functionality using interrupts

// Includes
#include "usart_interrupt.h"

// Function declarations (private)
// Initlialize USART RX and TX using interrupts some data via USART2 using interrupts
void usart2_rxtx_interrup_init(void)
{
	// Disable IRQs globally

	// Enable clock access to USART2, GPIOA, SYSCFG (no need to check if clock access is already enabled - waste of cpu clocks)
	RCC->APB1ENR |= USART2_CLK_EN;
	//RCC->APB2ENR |= SYSCFG_CLK_EN;

	// Set up the pins for USART RX (PA3), and set the alternate function type
	GPIOA->MODER &= ~(1UL << 6);
	GPIOA->MODER |= (1UL << 7);
	GPIOA->AFR[0] |= (1 << 12 | 1UL << 13 | 1UL << 14);
	GPIOA->AFR[0] &= ~(1UL << 15);

	// Configure the control register to setup the number of bits per data, oversampling rate (OVER8 bit) and enable RX
	// Set every bit other than bit 2 to 0
	USART2->CR1 = 0;
	USART2->CR1 |= (1UL << 2);

	// Set up the baudrate in BRR, by writing the mantissa and decimal of USARTDIV required for the desired baudrate
	// We want a baudrate of 115200 - so BSRR = cloq_freq / (8 * (2 - OVER8_bit)) * USART_DIV with clock_freq = 16000000
	USART2->BRR |= 0x008B;

	// Set both CR2 and CR3 to 0
	USART2->CR2 = 0;
	USART3->CR3 = 0;

	// Enable interrupt for USART2 using the RXNEIE (RXNE interrupt enable bit) in Control Register 2
	// Now whenever there is some data in the data register (and shift register becomes empty), an interrupt is generated
	USART2->CR1 |= USART2_RXNEIE;

	// Enable USART2
	USART2->CR1 |= USART2_EN;

	// Enable the interrupt request (IRQ) in NVIC, for USART Interrupt request number
	NVIC_EnableIRQ(USART2_IRQn);

	__enable_irq();
}
