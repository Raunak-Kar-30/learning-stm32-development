// File containing all the functions and ISRs for showcasing various interrupt functionalities

// Includes
#include "interrupts.h"

// Global variables
// Store the interrupt line
uint32_t EXTI_NUM = -1;

// Function declarations (private)
void systick_delay_ms(int ms);

// Functions
// Blink LED using buttons
// This function also showcases handling of two seperate interrupts through the same IRQ (40)
void blink_led_on_button_press(void)
{
	// Since the USR button is connected to PC12, we set it up to generate interrupts, which we then handle using an ISR (which blinks the LED twice)

	// Disable the IRQs globally
	__disable_irq();

	// ---------------- Setup the pins --------------------------------------------------
	// Enable clock access to the ports (PORT A and B) and SYSCFG for interrupt configuration
	if(!(RCC->AHB1ENR & GPIOA_CLK_EN)) RCC->AHB1ENR |= GPIOA_CLK_EN;
	if(!(RCC->AHB1ENR & GPIOC_CLK_EN)) RCC->AHB1ENR |= GPIOC_CLK_EN;
	if(!(RCC->APB2ENR & SYSCFG_CLK_EN)) RCC->APB2ENR |= SYSCFG_CLK_EN;

	// Set PA5 (USR_LED) as output and PC12 and PC10 as buttons as input (for interrupt)
	// Set both the buttons to pull-up configuration
	GPIOA->MODER |= (1UL << 12);
	GPIOA->MODER &= ~(1UL << 13);
	GPIOC->MODER &= ~(1UL << 20 | 1UL << 21 | 1UL << 24 | 1UL << 25);
	GPIOC->PUPDR |= (1UL << 20 | 1UL << 24);
	GPIOC->PUPDR &= ~(1UL << 21 | 1UL << 25);

	// ----------------- Enable the appropriate EXTI channel ----------------------------
	// We need to enable EXTI12 (12th external interrupt controller) for PORT C to enable interrupt generation for PC12
	// To do so, we set the EXTI10 of System Configuration Register 3 (SYSCFG_EXTI[2] register) and EXTI12 bits (bits 7,6,5,4) of -
	// System Configuration EXTI Control register 4 (SYSCFG_EXTI[3] register) to 0010 (to choose PORT C's 10th and 12th pin)
	SYSCFG->EXTICR[2] |= (1UL << 9);
	SYSCFG->EXTICR[2] &= ~(1UL << 8 | 1UL << 10 | 1UL << 11);
	SYSCFG->EXTICR[3] |= (1UL << 1);
	SYSCFG->EXTICR[3] &= ~(1UL << 0 | 1UL << 2 | 1UL << 3);

	// ----------------- Setup and configure the EXT Interrupt (EXTI12) -----------------
	// Disable masking of this interrupt by setting the MR12 bit of the EXTI Interrupt Mask register (see ref manual - RM0390 page : 244)
	EXTI->IMR |= EXTI10_UNMASK;
	EXTI->IMR |= EXTI12_UNMASK;

	// Set the appropriate trigger register to detect the needed interrupt signal (rising edge or falling edge trigger detection)
	// Since PC12 and PC10 is configured to be pull-up, that means the line stays high until the button is pressed
	// When the button is pressed the line is pulled low and hence a falling edge occurs. So we need to configure the FTSR for PC12 (or EXTI 12)
	EXTI->FTSR |= EXTI10_FTSR_EN;
	EXTI->FTSR |= EXTI12_FTSR_EN;

	// Next we enable EXTI10 and EXTI12 in NVIC
	// To do this however we use the CMSIS provided by ARM themselves (not STM) to enable the interrupt for EXTI10 and EXTI12
	// (see page 220 ARM Generic User guide - ARM DUI 0553B)
	// Since EXTI12 and EXTI10 are connected to IRQ40 (interrupt request number 40 - see page 238 of RM0390 - ref manual), we enable IRQ for that line
	NVIC_EnableIRQ(EXTI15_10_IRQn);			// Here EXTI15_10_IRQn is defined in stm32 header files to make it easier to locate the required IRQ number

	// Enable IRQs globally
	__enable_irq();
}

// Recieve some data via USART2 using interrupts
void usart2_rx_using_interrupt(void)
{
	// Enable clock access to USART2, GPIOA, SYSCFG if not already enabled
	if(!(RCC->AHB1ENR & (GPIOA_CLK_EN))) RCC->AHB1ENR |= GPIOA_CLK_EN;
	if(!(RCC->APB1ENR & (USART2_CLK_EN))) RCC->APB1ENR |= USART2_CLK_EN;
	if(!(RCC->APB2ENR & (SYSCFG_CLK_EN))) RCC->APB2ENR |= SYSCFG_CLK_EN;
}

// ISR (interrupt service routine) for EXTI12 and EXTI 10 (IRQ40) - blink led 2 times
// We must see from the startup assembly code provided by cubeide to see the IRQ handler name for our particular interrupt.
// In line 189 of 'startup_stmf446retx.s' we see that the interrupt handler name under the vector table (line 122) is defined as 'EXTI15_10_IRQHandler'
// So we must use this function name to overwrite the pre-defined ISR with our own ISR for handling interrupt related to EXTI12
void EXTI15_10_IRQHandler(void)
{
	// Check if RCC and pins are setup and setup them if not
	if(!(RCC->AHB1ENR & (GPIOA_CLK_EN))) RCC->AHB1ENR |= GPIOA_CLK_EN;
	if((GPIOA->MODER && (1UL << 12)) == 0) GPIOA->MODER |= (1UL << 12);
	if((GPIOA->MODER && (1UL << 13)) == 1) GPIOA->MODER &= ~(1UL << 13);

	// When the interrupt occurs (at falling edge or button press) the pending register of the corresponding EXTI line gets set
	// Check which request is being asked for by checking the EXTI Pending register (EXTI->PR)
	// If interrupt is from EXTI10 (PC10)
	if(EXTI->PR & (1UL << 10))
	{
		// Turn the LED on and off two times
		for(int i = 0; i < 2; i++)
		{
			GPIOA->BSRR |= (1UL << 6);
			systick_delay_ms(25);
			GPIOA->BSRR |= (1UL << (6+16));
			systick_delay_ms(25);
		}

		// We need to reset this bit at the end of the ISR. Writing 1 to this bit clears it (see RM 0390 - ref manual page 246)
		EXTI->PR |= (1UL << 10);
		return;
	}

	// If interrupt is from EXTI12 (PC12)
	else if (EXTI->PR & (1UL << 12))
	{
		// Turn the LED on and off two times
		for(int i = 0; i < 4; i++)
		{
			GPIOA->BSRR |= (1UL << 6);
			systick_delay_ms(25);
			GPIOA->BSRR |= (1UL << (6+16));
			systick_delay_ms(25);
		}

		// We need to reset this bit at the end of the ISR. Writing 1 to this bit clears it (see RM 0390 - ref manual page 246)
		EXTI->PR |= (1UL << 12);
		return;
	}
}
