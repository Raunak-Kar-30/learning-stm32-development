// Driver program for implementing the USART RX and TX functionality using interrupts

// Includes
#include "usart_interrupt.h"

// Function declarations (private)
// Initlialize USART RX and TX using interrupts some data via USART2 using interrupts
void usart2_rxtx_interrup_init(void)
{
	// Disable IRQs globally
	__disable_irq();

	// Enable clock access to USART2, GPIOA, SYSCFG (no need to check if clock access is already enabled - waste of cpu clocks)
	RCC->APB1ENR |= USART2_CLK_EN;

	// Set up the pins for USART RX (PA3), and set the alternate function type
	GPIOA->MODER &= ~(1UL << 6);
	GPIOA->MODER |= (1UL << 7);
	GPIOA->AFR[0] |= (1 << 12 | 1UL << 13 | 1UL << 14);
	GPIOA->AFR[0] &= ~(1UL << 15);

	// Configure the control register to setup the number of bits per data, oversampling rate (OVER8 bit) and enable RX
	// Set every bit other than bit 2 to 0
	USART2->CR1 = 0;
	USART2->CR1 |= (1UL << 2);

	// Set up the baudrate in BRR, by writing the mantissa and decimal of USARTDIV required for the desired baudrate
	// We want a baudrate of 115200 - so BSRR = cloq_freq / (8 * (2 - OVER8_bit)) * USART_DIV with clock_freq = 16000000
	USART2->BRR |= 0x008B;

	// Set both CR2 and CR3 to 0
	USART2->CR2 = 0;
	USART3->CR3 = 0;

	// Enable interrupt for USART2 using the RXNEIE (RXNE interrupt enable bit) in Control Register 2
	// Now whenever there is some data in the data register (and shift register becomes empty), an interrupt is generated
	USART2->CR1 |= USART2_RXNEIE;

	// Enable USART2
	USART2->CR1 |= USART2_EN;

	// Enable the interrupt request (IRQ) in NVIC, for USART Interrupt request number
	NVIC_EnableIRQ(USART2_IRQn);

	// Enable IRQs globally
	__enable_irq();
}

// Redefine the ISR for USART interrupt request. For that we redefine the function 'USART2_IRQHandler()' defined in line 187 of 'startup_stm32f446retx.s'
void USART2_IRQHandler(void)
{
	char data;

	// We need to poll the RXNE bit anymore, since the USART module automatically generates an interrupt whenever the RXNE bit is set
	// We just check if the RXNE bit is set, and if so then read the data register
	if(USART2->SR & (1UL << 5))
	{
		data = USART2->DR;
		if(data >= '0' && data <= '9') blink_usr_led(data-48);
	}
}
